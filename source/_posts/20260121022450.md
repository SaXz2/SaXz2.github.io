---
permalink: /20260121022450/
title: Kiro IDE + OpenSpec 实战：利用Spec以及多Ai工具降低抽卡概率 
date: "2026-01-21 02:24:50"
updated: "2026-01-21 02:24:50"
tags:
  - 产出
  - Github
  - Ai编程
  - AI Spec 范式开发
comments: true
toc: true
---

Kiro IDE + OpenSpec 实战：利用Spec以及多Ai工具降低抽卡概率 

## 引言

在上一期内容中，我们安装了 Roo Code、CLINE 和 Kilo Code 等 AI 插件，但如何将这些工具深度嵌入开发工作流？本期将以 **Kiro IDE** 为核心，实战演示如何配置并协同这些工具，高效开发一个“全局记忆”功能。

**为什么选择 Kiro IDE？**

- **极致性价比：**目前 Kiro 账号额度极高（约 1 元换取 550 次调用），相当于拥有近乎无限使用的 Claude 4.5 Opus

- **上下文无感切换：**切换账号后不会像 Cursor 那样清除上下文，配合切号器可实现丝滑续航。

## 一、 环境配置与工具协同

### 1. 规范化 Spec 管理

Kiro 目前暂不支持 **OpenSpec** ，其自带的 Spec 存储在 `.kiro` 文件夹中。

- **痛点：**Kiro 的 Spec 缺少归档功能，且在处理简易任务时流程略显臃肿。

- **解决方案：**

### 2. 插件配置（Roo Code / CLINE / Kilo Code）

三者配置大同小异，核心参数如下（就上期的反代）：

- **API Provider:**选择`OpenAI Compatible`

- **Base URL:**`http://127.0.0.1:8317/v1`

- **模型选择:**`gemini-1.5-pro-preview`/`gemini-1.5-flash-preview`/`gemini-2.0-pro`

- **Context Window:**设置为`512,000`（若超过此上限建议新开对话，否则幻觉会加重）。

> 💡 避坑：
> 
> 若 Roo Code 无法正常对话，请勾选“`使用传统 OpenAI API 格式`”。若连接不稳定或 Token 损耗过高，建议优先使用 CLINE 或 Kilo Code。

## 二、 实战演示：开发“全局记忆”功能

核心思路是：**利用 CLINE 规划方案（节省 Token） → 利用 Kiro 审核改进（确保质量） → 利用 Kilo Code 进行最终评估。**

### 第一步：需求定义 (Requirements Phase)

1. 在 Kiro 中新建对话，选择**Spec 模式**。

1. 输入需求描述（例如：实现全局记忆功能）。

1. **技巧：**我先用 CLINE 生成了一份方案文档（`global-memory-design.md`），让 Kiro 参考此文档进行审核。

1. Kiro 会自动读取项目结构，并生成  `requirements.md`。

### 第二步：逻辑迭代与确认

仔细阅读 Kiro 生成的需求文档。例如，在本项目中，我发现需要区分“多用户/角色管理”：

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/PixPin_2025-12-26_01-33-36-csqtufk31jpcb.avif)

### 第三步：第三方二次审查

切换到 **Kilo Code** 的 Architect 模式，让其对 `.kiro/specs` 下的需求文档进行评分。

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/PixPin_2025-12-26_01-34-52-f0d8xqmjcr020.avif)

- **案例：**Kilo Code 可能会指出“缺失注入模式设计（Injection Mode）”等潜在问题。

- **操作：**将 Kilo Code 的审核意见反馈给 Kiro，点击**Move to design phase**进入设计环节。

> 💡 避坑：
> 
> 建议关闭 Kilo Code 的“自动写入批准”，避免在未审查的情况下被 AI 误改核心代码。
> 
> ![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/PixPin_2025-12-26_01-38-19-d4u6a9rkmf7ng.avif)
> 
> Kilo Code 会比较方便能直接读到我们当前打开的文档，使用 Roo Code、CLINE、Kilo Code、 任一一个都可以

## 三、 自动化执行与任务交付 (Task Phase)

进入 Task 环节后，即可开始一键执行代码编写。

**⚠️ 自动化执行避坑指南：**

1. **分级执行：**不需要点击所有的 Start Task，直接点击一级序号（如 1. 2.），AI 会自动按序执行子任务。

1. **跳过非必要任务：**带有`- [ ]*`格式的任务被视为非必要，AI 不会主动执行。

1. **格式纠错：**如果没有出现 "Start Task" 按钮，说明 AI 生成的任务格式有误，请要求其修正为`- [ ]`标准列表格式。

## 四、 版本控制与开发进阶 FAQ

功能测试通过后，通过 IDE 的源代码管理提交代码，并在备注中写明关联的 Spec：

示例：`实现全局记忆功能 | Spec: (Kiro) global-memory-management`

### 进阶问答：关于分支管理与协作

1. **如何创建与切换分支？**

1. **为什么在 PR（拉取请求）时不要动 main 分支？**

1. **如何同步上游（原库）更新？**

1. **如何 Fork 代码库？**

另外推荐用 Ugit 图形化傻瓜式管理。

## 补充进阶：利用 Steering 与 Hooks 消除更多的幻觉概率提高抽卡成功率

在 AI 开发中，所谓的“抽卡概率低”（幻觉多、逻辑乱），本质是因为 AI 的**决策自由度过高**。我们要做的，就是通过约束（提示词），而通过Steering和 Hooks可以更好的的让它从“乱跑的哈士奇”变成“导盲犬”。

在 Kiro 中，这两个功能通常存放在 `.kiro/steering` 和 `.kiro/hooks`（或在项目根目录配置）。

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/PixPin_2025-12-26_05-53-26-y7nktbnyn0ad5.avif)

### Agent Steering

这个没什么可说的本质上就是一个全局规范，会引导AI基于此手册走向正确的道路

例如：写上如果 `不管我问什么，请在回答的开头先夸我是一句天才。` 这样每一句都会被此 `Steering`影响，本质的逻辑就是把此提示词权重拉到最高，这点有区别于全局记忆

使用也很简单，点上图的加号就行

### Agent Hooks 

就是AI驱动的自动化脚本而已

比如让其一直检测代码，当个质量检测员

使用方法也很简单

点击加号

输入需求

生成Hook

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/PixPin_2025-12-26_05-59-12-3acwuz2figl6d.avif)


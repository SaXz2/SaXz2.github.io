---
permalink: /20260121003109/
title: 【一站式Ai配置指南】Spec 驱动开发 + Gemini 本地反代 + MCP 配置全流程攻略
date: "2026-01-21 00:31:09"
updated: "2026-01-21 00:31:09"
tags:
  - 产出
  - Ai编程
  - AI Spec 范式开发
  - windows
  - Github
comments: true
toc: true
---

【一站式Ai配置指南】Spec 驱动开发 + Gemini 本地反代 + MCP 配置全流程攻略

## 前置条件

### Google 账号 有Pro更好

我买的时候 咸鱼**20**块钱

### Codex Team 账号

我买的时候 咸鱼**8.8**块钱

为啥用这个：它虽然很慢，但是查BUG，是目前效果最好的。

### Claude Code 可以用自定义API 主要是为了使用 Opus 4.5  

用免费号池也可、用GLM4.6套餐首月 **25**块钱、方案比较多看自己选择

白嫖可以用 **Antigravity **

但不一定能登录进去，可能需要买新号（**6块**）或者转区，有些费事，时间成本比较大

另外也可以在淘宝或者咸鱼搞其他的IDE

**例：**Kiro 

自带范式开发也有 Opus 4.5 

缺点是额度较少 六七块钱 550的额度，可能不够用

个人体验上一般，速度不如 Cursor 快 ， 但考虑到其极低的时间成本，所以值得一提

**其他：**Trae、Qoder、什么乱七八糟的IDE都可以去试试各有优劣，有些模型可以免费用，国内的都比较一般，当玩具就行，你也可以同时开多个IDE来开发，把他们各自的优点都发挥出来，利用Git来实现迭代和分支即可。

### 梯子

最好是支持 Clash Vegas 的梯子，我个人常用的是 [蓝海加速](https://app.lanhai.in:7779/#/register?code=4iun77aZ) 有需要的可以尝试一下

### Cursor 非必要

 有便宜的就用，没有替代也多，个人比较喜欢，因为速度快，但是生成的结构很烂， 2.0 会好用很多有个内置浏览器可以选元素直接改

## 需要软件：

**VS Code** （IDE）

**Roo Code** （VS Code 插件）

**Cline** （VS Code 插件）

**Claude Code**（VS Code 插件）

**Codex**（VS Code 插件）

**Cherry Studio** （桌面对话）

**CLIProxyAPI**（反代 Geimi）

能将 Gemini 的 API 伪装成 OpenAI 格式

**OpenSpec** (范式工具，也可以使用其他的比如 Spec Kit)

**iflow **(免费 CLI) 

用于调用虎鲸 MCP ， 免费且好用 ，适合轻量级使用

## 第一步：安装依赖和工具软件

**VS Code**: [Visual Studio Code - The open source AI code editor](https://code.visualstudio.com/)

VS Code 插件 ： 根据红框依次输入**Roo Code、 ** **Cline、Claude Code、Codex、**安装即可

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_06-14-18-kboaddmggose9.avif)

**Cherry Studio  **[客户端下载 | Cherry Studio](https://docs.cherry-ai.com/cherry-studio/download)

**CLIProxyAPI** [router-for-me/CLIProxyAPI](https://github.com/router-for-me/CLIProxyAPI/tree/main)

**OpenSpec**

1. `Win+X 后按 A` 

1. `npm install -g @fission-ai/openspec@latest`

1. 可选 ： 安装**Spec Kit** `npm install -g @github/spec-kit`

## 第二步：配置CLIProxyAPI 反代 和 Cherry Studio

官方参考教程：[快速开始 | CLIProxyAPI](https://help.router-for.me/cn/introduction/quick-start.html)

傻瓜式配置教程，请按顺序跟随教程完成即可

[壹：项目介绍+Qwen实战 | CLIProxyAPI](https://help.router-for.me/cn/hands-on/tutorial-1.html) 

[贰：Gemini CLI+Codex实战 | CLIProxyAPI](https://help.router-for.me/cn/hands-on/tutorial-2.html)

## 第三步：配置 iflow 以及MCP

教程频教程：[让你的AI助手帮你读写笔记，虎鲸笔记MCP接入实战_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YNa2zEEjW/?spm_id_from=333.1387.search.video_card.click&vd_source=473bd08df9aa1e3da7d4dc1971c54ee8)

官方教程：[快速开始 | 心流开放平台](https://platform.iflow.cn/cli/quickstart)

上述两个教程非常细致了，所以就不多说了

### 什么是MCP

**MCP (Model Context Protocol)**，全称“模型上下文协议”。它是 Anthropic（Claude 的母公司）发布的一项开放标准。

你可以把它理解为 **AI 界的 USB 接口**。

在没有 MCP 之前，AI 就像是一个关在笼子里的大脑，它只能通过你复制粘贴给它的信息来工作。有了 MCP，AI 就像是插上了 USB 线，可以直接读取你的本地文件、访问你的数据库、甚至操作你的各种开发工具。

### MCP有什么用：以“视频笔记整合”为例

**辣子鸡：**当你面对四个不同版本的辣子鸡制作视频时，传统的做法是逐一观看并手动对比。但在 **MCP ** **+ 插件 **下，你可以实现流程闭环：在网上看到 4 种做法，懒得看视频。AI 通过总结抓取信息，再配合 MCP 检索你笔记里的口味偏好。它能瞬间输出一份**“融合了 4 家长处、避开所有坑、且符合你口味”**的菜谱。相比直接使用Ai信息来源使用的是你的笔记避免很多的幻觉。

利用插件自动识别链接并插入视频

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_08-16-26-tgvwy71r6yty6.avif)

利用 AI 自动提取字幕并对视频总结，生成可跳转的时间戳

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_08-17-21-mtxp8bzpl4zk8.avif)

通过 MCP 仅对话笔记中的内容，AI 可以跨块检索、对比不同方案的优劣，并输出一份融合各家所长的“最优解”

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/39582bb7de6249f7cad002362c0f5e75-p9awli8ac12zu.avif)

### MCP有什么用

### 利用MCP检索总结生成

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_08-39-31-xnobmwgp59hws.avif)

### Gemini 生成

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_08-44-22-2ic7rnozoi71l.avif)

### 总结

**直接对话**

给我的答案是一种通用式回答来源AI 训练时看过的数据，像是在翻《百科全书》，给出的步骤是“平均值”。

**利用 MCP **

抓取本地笔记，生成高价值密度的信息，聚焦于给予的数据来生成

---

可以看得出来，利用MCP总结的信息明显更有价值，两者结合才是更好用的。



## 第四步：范式流程

### 什么是范式开发

**范式开发”（Paradigm-driven Development）**

可以理解为：“**先定规矩，再干活**”

它不再是让你直接去写代码，而是让你先确立一套**标准化的开发模式（Paradigm）**，让 AI 在这套框架内进行。

**非范式开发（Vibe Coding / 氛围感编程）：** 

像是在玩“词语接龙”。你给 AI 一个模糊的需求，AI 凭感觉写一段代码，你发现不对再改，改了再试。这种方式效率高，但像碰运气，代码写多了就会乱成一团（屎山）。

### 为什么要搞“范式开发”？

**消除“幻觉”：** AI 之所以乱写，是因为它不知道你的边界。范式开发通过 Spec（开工手册）给它画了圈，它就只能在圈里跳舞。

**保持一致性：** 如果是多个人或多个 AI 协同，范式确保了代码风格、逻辑结构是一模一样的，而不是各写各的。

**可回溯：** 报错了或者功能不对，你可以直接回看 Spec（开工手册），确定是“设计错了”还是“写错了”。

### 范式开发 0到1

不同的SDD范式有着不同的范式逻辑，在构建项目时也应根据不同的项目使用不同的范式工具，从0到1，选择** Spec-Kit** 和 **BMAD **是更好的选择，他们更加注重初期的 Spec（开工手册）构建

不急于写第一行代码，而是利用 **Spec-Kit** 或 **BMAD** 先和 AI 磨合出一份详尽的**“开工手册”**。这份手册规定了项目的架构逻辑、技术选型和目录结构。

#### ** Spec-Kit** 和 **BMAD **的区别

**BMAD相比Spec-Kit最大的区别就是由谁写开工手册** 

**Spec-Ki**由你引导 AI 写 ， 你是个“导演”

**BMAD**由你和多个不同Ai同时写，Ai也可能会追问你不同的开工手册细节来逐步完善，你更像是个“甲方”

所以在这种逻辑不同上 BMAD 要比 Spec-Kit 更加耗费Token

### 范式开发 1到N

假设我们在开发“虎鲸笔记 SRS 插件”，由于已有成熟框架，**OpenSpec** 的灵活性是最好的。它不需要事无巨细地写文档，而是通过“差异描述”快速落实规范。**Token 消耗也是最少的**。

补充：

### 灵活变通：没有死板的流程

所有的开发范式都是可以**来回套用**的：你可以初期用 **BMAD** 构建厚重可靠的地基。后期转用 **OpenSpec** 进行快速的功能迭代。甚至可以先 **Vibe Coding** 出一个原型，再用范式工具将其标准化。

**核心只有一个：** 保持项目的“脚手架结构”统一。

### 范式开发 **OpenSpec** 的使用方式

其他的不讲了可以自行查阅教程或Ai，都大差不差了，没什么太大区别

---

项目文件夹内打开控制台 输入 `OpenSpec init` 初始化

复制 **OpenSpec **提供的三行代码到对应工具中

补充：init之后，不要无脑复制那三行prompt ,算是一个小技巧，不过直接复制也没什么一样用

先复制这段（Please read openspec/project.md and help me fill it out with details about my project, tech stack, and conventions）

再输入 （为现有功能创建openspec规格文档）用英文更好 （Create OpenSpec specification documents for existing functionality）

再输入 三行prompt的第二个 prompt 

输入 /openspec:proposal fix-answer-block-rendering 需求文件名即可（这里用的 Claude Code，其他的命令可能不一样） 此时就会创建实现的说明书

![](https://raw.githubusercontent.com/SaXz2/Orca-Images/main/img/D%3A/Obsidian_StudyAndPic/orca/repos/iwy5nfalj9l1y/assets/PixPin_2025-12-24_08-25-18-0ql3dkhgdtxko.avif)

审查实现逻辑进行改进：例如： 请修改 fix-answer-block-rendering 提议：修正提案中的缩进层级描述，将目标从`indentLevel=1`改为`indentLevel=0`

输入 /openspec:apply fix-answer-block-rendering 来执行Tasks 

最后再用/openspec:archive 完成归档即可

合并以后数据会存到 openspec/specs中 ， 移动变更至 openspec/archive ， 清空openspec/changes ，并生成时间戳

---

openspec/project.md：存放项目的“全局人设”（用什么框架、什么命名规范）。

openspec/specs/：存放具体的“功能说明书”。

## Git说明

### 什么是 Git？

简单来说，它就是一个专门记录文件内容变化的软件。它能帮你把项目的每一个阶段都拍成“快照”，让你随时可以查阅历史，或者在写错代码时“一键穿越”回过去。

### 为什么需要 Git？

在没有 Git 的时代，我们修改项目通常是这样的 

`虎鲸笔记插件_初稿.zip`

`虎鲸笔记插件_改算法版.zip`

`虎鲸笔记插件_最终版.zip`

`虎鲸笔记插件_绝对不改最终版_真的最后一次.zip`

**无法找回：** 你删了一段代码，第二天想找回来？基本靠记性。

**容易覆盖：** 两个人同时改一个文件，后保存的那个人会直接把前一个人的心血抹掉。

**不敢乱动：** 想试个新功能？怕把原来的搞坏，只能不停地手动复制备份。

### Git 有什么用？

#### 存档

你可以把 Git 想象成游戏的“存档点”。每当你完成了一个小功能（比如写完了 SRS 算法），你就进行一次 `Commit`。如果之后代码改崩了，你只需要点一下，项目就能瞬间回到那个健康的存档点。

#### 分身

测试一个非常大胆的新功能，但又怕把现有的稳定版搞乱。这时候可以开一个**“分支（Branch）”**

随便折腾，原版代码丝毫不受影响。

试成功了，就合并（Merge）回去；试失败了，直接删除这个分支，主代码依然干干净净。

#### 协作

如果你和伙伴一起开发，Git 会自动对比你们俩改动了哪里。

如果你们改了同一个地方，Git 会提醒你处理“冲突”，而不是直接覆盖。

这时候用Ai 也方便合一起再出个合并 Spec ，每一次的 Spec 都带有文档说明，方便回顾

### Git 核心术语一览

**Repository (仓库)**你的项目文件夹存放代码和所有历史记录的地方。

**Commit (提交)**存档/拍照保存当前代码的状态，并写下一句备注。

**Branch (分支)**开启平行宇宙在不影响主线的情况下开发新功能。

**Merge (合并)**宇宙合一将分支上的新功能合并回主代码中。

**Remote (远程)**云端备份指向 GitHub 等平台的服务器地址。

**Pull (拉取)：** 把云端的代码同步到本地。如果你的伙伴改了代码，你得先 Pull 才能继续。

**Push (推送)：** 把你的本地“保险库”同步到云端（GitHub/Gitee）。

**Conflict (冲突)：** 当 AI 改了第 10 行，你也改了第 10 行，Git 会停下来问你：“老板，听谁的？”这是保护代码不被乱覆盖的最后防线。

**Checkout / Switch (切换)：** 在不同的分身（分支）之间瞬间移动。

### 范式开发中的 Git 最佳实践建议

**一功能一分支：** 开发“虎鲸笔记 SRS 算法”时，不要在 `main` 分支写。开个 `feat-srs-algorithm` 分支。

不过小项目，我更加推荐直接黑盒子AI，直接让他写就完事了，轮子能转就行






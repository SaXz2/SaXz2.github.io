---
permalink: /20260121021205/
title: 250525 基于摄像机的遮挡与可变点缩放效果 Epi.13
date: "2026-01-21 02:12:05"
updated: "2026-01-21 02:12:05"
tags:
  - CG相机技巧
  - Houdini技巧
  - POP
  - Note
  - Block
comments: true
toc: true
---

250525 基于摄像机的遮挡与可变点缩放效果 Epi.13

有啥用？

**遮挡（Occlusion）： **避免 “穿帮”，比如烟雾粒子重叠时，后面的粒子被前面的挡住，符合真实视觉。

**点缩放（pscale）：**远处的鸟看起来小，近处的鸟看起来大。

剔除摄像机外的内容

 参考这个就行了，作者是用UVtexture 计算的屏幕UV，原理一样

计算中心点 使用 fromNDC 计算出屏幕中心点

利用中心点计算出指向屏幕的法线方向

```js
vector p0 = fromNDC(cam,set(0.5,0.5,0)); 
// fromNDC函数：将标准化设备坐标（NDC，范围0-1）转换为相机空间坐标
// set(0.5,0.5,0)：NDC坐标的中心（画面正中间），z=0代表相机平面（近裁剪面）
// 类比：p0是相机平面的中心点，相当于“镜头正中央的位置”

vector p1 = fromNDC(cam,set(0.5,0.5,-0.0001)); 
// z=-0.0001：在相机前方极近的位置（稍微偏离相机平面一点点）
// 类比：p1是相机镜头前方一点点的位置，和p0形成一个极短的线段

// 3. 计算相机平面的法线方向n（从相机平面指向外侧）
vector n = normalize(p1-p0); 
// p1-p0：向量方向从p0到p1（即从相机平面指向相机前方）
// normalize：标准化向量，使其长度为1
// 类比：n是相机平面的“朝向”，就像相机镜头的“视线方向”
```

计算出所有点到屏幕中心的偏移量

使用点乘计算出投影距离也就是长度

再用这个长度值 * 当前点位置

```js
vector q = dot (p0 - @P , n) * n; 
// p0 - @P：向量从当前点@P指向相机平面中心点p0
// dot(..., n)：计算该向量在法线n方向上的投影长度（带正负号）
// 再乘以n：将投影长度转换为向量形式，得到点@P到相机平面的垂直距离向量
// 类比：q是当前点到相机平面的“垂直距离箭头”，箭头长度就是距离，方向是相机法线n

// 5. 存储距离值到@dist属性
@dist = length(q); 
// 取q的长度，得到点到相机平面的实际距离（无方向的数值）
// 类比：@dist记录“当前点离相机平面有多远”

// 6. 存储投影后的点位置到v@Q属性
v@Q = @P + q; 
// @P + q：将当前点沿法线n方向移动到相机平面上，得到投影点Q
// 类比：v@Q是当前点在相机画面中的“投影位置”，就像把点“拍扁”到相机平面上

// 7. 存储法线方向到@N属性
@N = n; 
// 记录相机平面的法线方向，后续可能用于遮挡计算或光照计算
// 类比：@N记住“相机镜头的朝向”，方便后续判断前后遮挡
```

使用摄像机剔除遮挡点

使用pcfind_radius 找到所有重叠点

循环数组得到所有重叠点到相机的距离的数组

再用 `pts = reorder ( pts, argsort ( dist ) );` 重新排序 按照到相机距离从小到大的顺序排列

最后再删除数组索引0以外的就行了



